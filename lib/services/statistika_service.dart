import 'dart:async';
import 'dart:math'; // üöó DODANO za kilometra≈æu kalkulacije

import 'package:async/async.dart'; // Za StreamZip i StreamGroup
// DateFormat import removed - not needed after debug cleanup
import 'package:rxdart/rxdart.dart'; // üîß DODANO za share() metodu
import 'package:supabase_flutter/supabase_flutter.dart'; // üöó DODANO za GPS podatke

import '../models/mesecni_putnik.dart';
import '../models/putnik.dart';
import '../utils/logging.dart'; // üîß DODANO za dlog funkciju
import '../utils/vozac_boja.dart'; // üéØ DODANO za listu vozaƒça
import 'clean_statistika_service.dart'; // üÜï DODANO za clean statistike
import 'mesecni_putnik_service.dart'; // üîÑ DODANO za meseƒçne putnike
import 'putnik_service.dart'; // üîÑ DODANO za real-time streams

class StatistikaService {
  StatistikaService._internal();
  // Singleton pattern
  static StatistikaService? _instance;
  static StatistikaService get instance =>
      _instance ??= StatistikaService._internal(); // Private constructor

  // Instance cache za stream-ove da izbegnemo duplo kreiranje
  final Map<String, Stream<Map<String, double>>> _streamCache = {};

  // üéØ CENTRALIZOVANA LISTA VOZAƒåA
  static List<String> get sviVozaci => VozacBoja.boje.keys.toList();

  // üïê TIMEZONE STANDARDIZACIJA - Koristimo lokalno vreme (SAMO DATUM)
  static DateTime _normalizeDateTime(DateTime dateTime) {
    return DateTime(dateTime.year, dateTime.month, dateTime.day);
  }

  // Debug logging completely removed for production build

  /// üí∞ JEDINSTVENA LOGIKA ZA RAƒåUNANJE PAZARA - koristi se svuda!
  static bool _jePazarValjan(Putnik putnik) {
    // Osnovni uslovi za validno raƒçunanje pazara
    final imaIznos = putnik.iznosPlacanja != null && putnik.iznosPlacanja! > 0;

    // ‚úÖ PRIORITET: naplatioVozac > vozac (SAMO REGISTROVANI VOZAƒåI)
    final registrovaniVozac = putnik.naplatioVozac ?? putnik.vozac;
    final imaRegistrovanogVozaca = registrovaniVozac != null &&
        registrovaniVozac.isNotEmpty &&
        VozacBoja.isValidDriver(registrovaniVozac);

    final nijeOtkazan = !putnik.jeOtkazan;
    final isValid = imaIznos && imaRegistrovanogVozaca && nijeOtkazan;

    return isValid;
  }

  /// üïê STANDARDIZOVANO FILTRIRANJE PO VREMENSKOM OPSEGU
  static bool _jeUVremenskomOpsegu(
    DateTime? dateTime,
    DateTime from,
    DateTime to,
  ) {
    if (dateTime == null) return false;
    final normalized = _normalizeDateTime(dateTime);
    final normalizedFrom = _normalizeDateTime(from);
    final normalizedTo = _normalizeDateTime(to);

    // ‚úÖ FIXED: Use proper inclusive date range comparison
    final result = !normalized.isBefore(normalizedFrom) &&
        !normalized.isAfter(normalizedTo);

    if (!result) {
    } else {}

    return result;
  }

  /// üí∞ PAZAR ZA ODREƒêENOG VOZAƒåA - KORISTI VREMENSKI OPSEG
  static Future<double> pazarZaVozaca(
    List<Putnik> putnici,
    String vozac, {
    DateTime? from,
    DateTime? to,
  }) async {
    // Ako nisu prosleƒëeni parametri, koristi dana≈°nji dan
    final now = _normalizeDateTime(DateTime.now());
    final fromDate = from ?? DateTime(now.year, now.month, now.day);
    final toDate = to ?? DateTime(now.year, now.month, now.day, 23, 59, 59);

    return _calculatePazarSync(putnici, vozac, fromDate, toDate);
  }

  /// üîÑ REAL-TIME PAZAR STREAM ZA ODREƒêENOG VOZAƒåA - JEDNOSTAVNO BEZ DUPLIKOVANJA
  static Stream<double> streamPazarZaVozaca(
    String vozac, {
    DateTime? from,
    DateTime? to,
  }) {
    final now = _normalizeDateTime(DateTime.now());
    final fromDate = from ?? DateTime(now.year, now.month, now.day);
    final toDate = to ?? DateTime(now.year, now.month, now.day, 23, 59, 59);

    // ÔøΩ SAMO KOMBINOVANI STREAM - ne duplikuj meseƒçne putnike!
    return PutnikService().streamKombinovaniPutniciFiltered().map((putnici) {
      // Debug: poka≈æi sample od najnovijih 6 putnika (ime, vozac, iznos, vremePlacanja)
      try {
        final sample = putnici
            .take(6)
            .map(
              (p) => {
                'ime': p.ime,
                'vozac': p.vozac,
                'iznos': p.iznosPlacanja,
                'vreme': p.vremePlacanja?.toIso8601String(),
              },
            )
            .toList();
        dlog('üîî [PAZAR DEBUG] sample putnici: $sample');
      } catch (_) {}
      final pazar = _calculateSimplePazarSync(putnici, vozac, fromDate, toDate);
      return pazar;
    });
  }

  /// ÔøΩ JEDNOSTAVNA KALKULACIJA PAZARA - KORISTI KOMBINOVANI STREAM - POPRAVLJENA LOGIKA
  static double _calculateSimplePazarSync(
    List<Putnik> kombinovaniPutnici,
    String vozac,
    DateTime fromDate,
    DateTime toDate,
  ) {
    double ukupno = 0.0;

    // üîß GRUPIRANJE MESEƒåNIH PUTNIKA PO ID (ne po imenu!) da se izbegne duplikovanje
    final Map<String, Putnik> uniqueMesecni = {};
    final List<Putnik> obicniPutnici = [];

    for (final putnik in kombinovaniPutnici) {
      if (putnik.mesecnaKarta == true) {
        // Za meseƒçne - grupi≈°i po ID da izbegne≈° duplikate
        final kljuc = '${putnik.ime}_${putnik.vozac}'; // Kompozitni kljuƒç
        if (!uniqueMesecni.containsKey(kljuc) && _jePazarValjan(putnik)) {
          uniqueMesecni[kljuc] = putnik;
        }
      } else {
        obicniPutnici.add(putnik);
      }
    }

    // Kombinuj unique meseƒçne i obiƒçne putnike
    final sviPutnici = [...uniqueMesecni.values, ...obicniPutnici];

    for (final putnik in sviPutnici) {
      if (_jePazarValjan(putnik) && putnik.vozac == vozac) {
        // Za SVE putnike (meseƒçne i obiƒçne) - raƒçunaj pazar SAMO ako je plaƒáen u tra≈æenom opsegu
        if (putnik.vremePlacanja != null &&
            _jeUVremenskomOpsegu(putnik.vremePlacanja, fromDate, toDate)) {
          final iznos = putnik.iznosPlacanja!;
          ukupno += iznos;
        }
      }
    }
    return ukupno;
  }

  /// üé´ STREAM BROJ MESEƒåNIH KARATA ZA ODREƒêENOG VOZAƒåA
  static Stream<int> streamBrojMesecnihKarataZaVozaca(
    String vozac, {
    DateTime? from,
    DateTime? to,
  }) {
    final now = _normalizeDateTime(DateTime.now());
    final fromDate = from ?? DateTime(now.year, now.month, now.day);
    final toDate = to ?? DateTime(now.year, now.month, now.day, 23, 59, 59);

    return MesecniPutnikService.streamAktivniMesecniPutnici()
        .map((mesecniPutnici) {
      int brojKarata = 0;
      for (final putnik in mesecniPutnici) {
        if (putnik.jePlacen &&
            putnik.vozac == vozac &&
            putnik.vremePlacanja != null &&
            _jeUVremenskomOpsegu(putnik.vremePlacanja, fromDate, toDate)) {
          brojKarata++;
        }
      }
      return brojKarata;
    });
  }

  /// üîÑ SINHRONA KALKULACIJA PAZARA (za stream)
  static double _calculatePazarSync(
    List<Putnik> putnici,
    String vozac,
    DateTime fromDate,
    DateTime toDate,
  ) {
    // 1. PAZAR OD OBIƒåNIH PUTNIKA
    final filteredPutnici = putnici.where((putnik) {
      if (!_jePazarValjan(putnik)) return false;
      if (putnik.vremePlacanja == null) return false;
      if (putnik.vozac != vozac) return false;

      return _jeUVremenskomOpsegu(putnik.vremePlacanja, fromDate, toDate);
    }).toList();

    double ukupnoObicni = filteredPutnici.fold<double>(
      0.0,
      (sum, putnik) => sum + (putnik.iznosPlacanja ?? 0.0),
    );
    // 2. STVARNI PAZAR OD MESEƒåNIH KARATA
    double ukupnoMesecne = 0.0;
    try {
      // Sinhrono raƒçunanje za stream - koristimo podatke iz putnici koji su meseƒçni
      final mesecniPutnici = putnici.where((putnik) {
        if (putnik.mesecnaKarta != true) return false;
        if (putnik.iznosPlacanja == null || putnik.iznosPlacanja! <= 0) {
          return false;
        }
        if (putnik.vozac != vozac) return false;
        if (putnik.vremePlacanja == null) return false;

        return _jeUVremenskomOpsegu(putnik.vremePlacanja, fromDate, toDate);
      }).toList();

      ukupnoMesecne = mesecniPutnici.fold<double>(
        0.0,
        (sum, putnik) => sum + (putnik.iznosPlacanja ?? 0.0),
      );
    } catch (e) {
      // ignore: empty_catches
    }

    final ukupno = ukupnoObicni + ukupnoMesecne;
    return ukupno;
  }

  /// üìä KOMBINOVANI REAL-TIME PAZAR STREAM (obiƒçni + meseƒçni putnici)
  static Stream<Map<String, double>> streamKombinovanPazarSvihVozaca({
    DateTime? from,
    DateTime? to,
  }) {
    final now = _normalizeDateTime(DateTime.now());
    final fromDate = from ?? DateTime(now.year, now.month, now.day);
    final toDate = to ?? DateTime(now.year, now.month, now.day, 23, 59, 59);

    // Kombinuj oba stream-a koristeƒái async*
    return instance._combineStreams(
      PutnikService().streamKombinovaniPutniciFiltered(),
      MesecniPutnikService.streamAktivniMesecniPutnici(),
      fromDate,
      toDate,
    );
  }

  /// üîÑ POMOƒÜNA FUNKCIJA ZA KOMBINOVANJE STREAM-OVA - SIMPLIFIKOVANO
  Stream<Map<String, double>> _combineStreams(
    Stream<List<Putnik>> putnicStream,
    Stream<List<MesecniPutnik>> mesecniStream,
    DateTime fromDate,
    DateTime toDate,
  ) {
    // üîß POJEDNOSTAVLJENO: Koristi CombineLatest2 umesto StreamGroup
    return CombineLatestStream.combine2(
      putnicStream,
      mesecniStream,
      (List<Putnik> putnici, List<MesecniPutnik> mesecniPutnici) {
        final rezultat = _calculateKombinovanPazarSync(
          putnici,
          mesecniPutnici,
          fromDate,
          toDate,
        );

        return rezultat;
      },
    );
  }

  ///  PUBLIC SINHRONA KALKULACIJA KOMBINOVANOG PAZARA (za external usage)
  static Map<String, double> calculateKombinovanPazarSync(
    List<Putnik> putnici,
    List<MesecniPutnik> mesecniPutnici,
    DateTime fromDate,
    DateTime toDate,
  ) {
    return _calculateKombinovanPazarSync(
      putnici,
      mesecniPutnici,
      fromDate,
      toDate,
    );
  }

  /// üîÑ SINHRONA KALKULACIJA KOMBINOVANOG PAZARA (obiƒçni + meseƒçni)
  static Map<String, double> _calculateKombinovanPazarSync(
    List<Putnik> putnici,
    List<MesecniPutnik> mesecniPutnici,
    DateTime fromDate,
    DateTime toDate,
  ) {
    // üéØ DINAMIƒåKA INICIJALIZACIJA VOZAƒåA - RESETUJ SVE!
    final Map<String, double> pazarObicni = {};
    final Map<String, double> pazarMesecne = {};
    for (final vozac in sviVozaci) {
      pazarObicni[vozac] = 0.0; // üîß RESETUJ NA 0!
      pazarMesecne[vozac] = 0.0; // üîß RESETUJ NA 0!
    }

    // 1. SABERI OBIƒåNI PAZAR iz putnici tabele - ISKLJUƒåI MESEƒåNE KARTE
    for (final putnik in putnici) {
      // üõë PRESKAƒåI MESEƒåNE KARTE - one se raƒçunaju odvojeno iz MesecniPutnikService
      if (putnik.mesecnaKarta == true) {
        continue;
      }

      if (_jePazarValjan(putnik) && putnik.vremePlacanja != null) {
        if (_jeUVremenskomOpsegu(putnik.vremePlacanja, fromDate, toDate)) {
          final vozac = putnik.vozac!;
          if (pazarObicni.containsKey(vozac)) {
            pazarObicni[vozac] = pazarObicni[vozac]! + putnik.iznosPlacanja!;
          }
        }
      }
    }

    // 2. SABERI MESEƒåNE KARTE - KORISTI vremePlacanja (kad je plaƒáeno) umesto placeniMesec

    // üí° GRUPIRAJ MESEƒåNE PUTNIKE PO ID DA SE IZBEGNE DUPLO RAƒåUNANJE
    final Map<String, MesecniPutnik> uniqueMesecni = {};
    for (final putnik in mesecniPutnici) {
      uniqueMesecni[putnik.id] = putnik;
    }

    for (final putnik in uniqueMesecni.values) {
      if (putnik.aktivan && !putnik.obrisan && putnik.jePlacen) {
        // üí∞ NOVA LOGIKA: Proveravamo da li je DANAS plaƒáeno (vremePlacanja), ne za koji mesec
        if (putnik.vremePlacanja != null &&
            _jeUVremenskomOpsegu(putnik.vremePlacanja, fromDate, toDate)) {
          final vozac = putnik.vozac ?? 'Nepoznat';
          final iznos = putnik.iznosPlacanja ?? 0.0;

          if (pazarMesecne.containsKey(vozac)) {
            pazarMesecne[vozac] = pazarMesecne[vozac]! + iznos;
          }
        } else {}
      } else {}
    }

    // 3. SABERI UKUPNO I VRATI REZULTAT
    final Map<String, double> rezultat = {};
    double ukupno = 0.0;

    for (final vozac in sviVozaci) {
      final ukupnoVozac = pazarObicni[vozac]! + pazarMesecne[vozac]!;
      rezultat[vozac] = ukupnoVozac;
      ukupno += ukupnoVozac;
    }

    // Dodaj ukupan pazar
    rezultat['_ukupno'] = ukupno;
    rezultat['_ukupno_obicni'] = pazarObicni.values.fold(0.0, (a, b) => a + b);
    rezultat['_ukupno_mesecni'] =
        pazarMesecne.values.fold(0.0, (a, b) => a + b);

    return rezultat;
  }

  ///  REAL-TIME PAZAR STREAM ZA SVE VOZAƒåE - POPRAVLJENA LOGIKA BEZ DUPLIKOVANJA
  static Stream<Map<String, double>> streamPazarSvihVozaca({
    DateTime? from,
    DateTime? to,
  }) {
    final now = _normalizeDateTime(DateTime.now());
    final fromDate = from ?? DateTime(now.year, now.month, now.day);
    final toDate = to ?? DateTime(now.year, now.month, now.day, 23, 59, 59);

    // üîß KORISTI KOMBINOVANI STREAM UMESTO DUPLO RAƒåUNANJE MESEƒåNIH
    return streamKombinovanPazarSvihVozaca(from: fromDate, to: toDate);
  }

  // Metoda za ƒçi≈°ƒáenje cache-a (korisno za testiranje ili promenu datuma)
  static void clearStreamCache() {
    instance._streamCache.clear();
  }

  /// ÔøΩüí∞ PAZAR PO SVIM VOZAƒåIMA - KORISTI VREMENSKI OPSEG
  static Future<Map<String, double>> pazarSvihVozaca(
    List<Putnik> putnici, {
    DateTime? from,
    DateTime? to,
  }) async {
    // Ako nisu prosleƒëeni parametri, koristi dana≈°nji dan
    final now = _normalizeDateTime(DateTime.now());
    final fromDate = from ?? DateTime(now.year, now.month, now.day);
    final toDate = to ?? DateTime(now.year, now.month, now.day, 23, 59, 59);

    // üéØ DINAMIƒåKA INICIJALIZACIJA VOZAƒåA
    final Map<String, double> pazarObicni = {};
    final Map<String, double> pazarMesecne = {};
    for (final vozac in sviVozaci) {
      pazarObicni[vozac] = 0.0;
      pazarMesecne[vozac] = 0.0;
    }

    // 1. SABERI OBIƒåNI PAZAR iz putnici tabele
    for (final putnik in putnici) {
      if (_jePazarValjan(putnik) && putnik.vremePlacanja != null) {
        if (_jeUVremenskomOpsegu(putnik.vremePlacanja, fromDate, toDate)) {
          // ‚úÖ SAMO REGISTROVANI VOZAƒåI: naplatioVozac > vozac (BEZ FALLBACK-a)
          final vozac = putnik.naplatioVozac ?? putnik.vozac!;
          // ‚úÖ Validacija da je vozaƒç registrovan
          if (pazarObicni.containsKey(vozac) &&
              VozacBoja.isValidDriver(vozac)) {
            pazarObicni[vozac] = pazarObicni[vozac]! + putnik.iznosPlacanja!;
          }
        } else {}
      }
    }

    // 2. SABERI MESEƒåNE KARTE - STVARNI PODACI
    try {
      // Uƒçitaj sve meseƒçne putnike
      final mesecniPutnici =
          await MesecniPutnikService().getAktivniMesecniPutnici();

      for (final putnik in mesecniPutnici) {
        // Proveri da li je putnik platio u ovom periodu
        if (putnik.vremePlacanja != null &&
            putnik.iznosPlacanja != null &&
            putnik.iznosPlacanja! > 0 &&
            putnik.vozac != null &&
            putnik.vozac!.isNotEmpty &&
            VozacBoja.isValidDriver(putnik.vozac!)) {
          if (_jeUVremenskomOpsegu(putnik.vremePlacanja, fromDate, toDate)) {
            // ‚úÖ SAMO REGISTROVANI VOZAƒåI za meseƒçne putnike
            final vozac = putnik.vozac!;
            if (pazarMesecne.containsKey(vozac)) {
              pazarMesecne[vozac] =
                  pazarMesecne[vozac]! + putnik.iznosPlacanja!;
            }
          }
        }
      }
    } catch (e) {
      // ignore: empty_catches
    }

    // 3. SABERI UKUPNO I KREIRAJ FINALNI MAP
    final Map<String, double> ukupnoPazar = {};
    double ukupno = 0.0;

    for (final vozac in sviVozaci) {
      final obicni = pazarObicni[vozac] ?? 0.0;
      final mesecne = pazarMesecne[vozac] ?? 0.0;
      final ukupnoVozac = obicni + mesecne;

      ukupnoPazar[vozac] = ukupnoVozac;
      ukupno += ukupnoVozac;

      if (ukupnoVozac > 0) {}
    }

    return {...ukupnoPazar, '_ukupno': ukupno};
  }

  /// Vraca detaljne statistike po vozacu - STVARNI MESEƒåNI PUTNICI
  static Future<Map<String, Map<String, dynamic>>> detaljneStatistikePoVozacima(
    List<Putnik> putnici,
    DateTime from,
    DateTime to,
  ) async {
    final normalizedFrom = _normalizeDateTime(from);
    final normalizedTo = _normalizeDateTime(to);

    final Map<String, Map<String, dynamic>> vozaciStats = {};

    // UƒåITAJ STVARNE MESEƒåNE PUTNIKE
    final mesecniPutnici = await MesecniPutnikService().getAllMesecniPutnici();

    // üéØ INICIJALIZUJ SVE VOZAƒåE SA NULAMA - DODANA POLJA ZA MESEƒåNE KARTE
    for (final vozac in sviVozaci) {
      vozaciStats[vozac] = {
        'dodati': 0,
        'otkazani': 0,
        'naplaceni': 0, // SAMO obiƒçni putnici
        'pokupljeni': 0,
        'dugovi': 0, // üÜï BROJ dugova (pokupljen ali nije plaƒáen)
        'ukupnoPazar': 0.0, // obiƒçni + meseƒçne karte
        'mesecneKarte': 0, // üÜï BROJ meseƒçnih karata
        'pazarMesecne': 0.0, // üÜï PAZAR od meseƒçnih karata
        'pazarObicni': 0.0, // üÜï PAZAR od obiƒçnih putnika
        'kilometraza': 0.0, // üöó KILOMETRA≈ΩA za taj dan
      };
    }

    for (final putnik in putnici) {
      // Proverava da li je putnik u datom periodu (po vremenu dodavanja)
      if (putnik.vremeDodavanja != null &&
          _jeUVremenskomOpsegu(
            putnik.vremeDodavanja,
            normalizedFrom,
            normalizedTo,
          )) {
        // 1. DODATI PUTNICI - ko je DODAO
        final dodaoVozac = putnik.dodaoVozac ?? 'Nepoznat';
        if (vozaciStats.containsKey(dodaoVozac)) {
          vozaciStats[dodaoVozac]!['dodati']++;
        }

        // 2. OTKAZANI - ko je OTKAZAO (ili ko je dodao ako nema otkazaoVozac)
        if (putnik.jeOtkazan) {
          final otkazaoVozac =
              putnik.otkazaoVozac ?? putnik.dodaoVozac ?? 'Nepoznat';
          if (vozaciStats.containsKey(otkazaoVozac)) {
            vozaciStats[otkazaoVozac]!['otkazani']++;
          }
        }

        // 3. POKUPLJENI - ko je POKUPIOVOZAC
        if (putnik.jePokupljen) {
          final pokupioVozac = putnik.pokupioVozac;
          if (pokupioVozac != null && vozaciStats.containsKey(pokupioVozac)) {
            vozaciStats[pokupioVozac]!['pokupljeni']++;
          }
        }

        // üÜï DUGOVI - pokupljen ali nije plaƒáen, nije otkazan, nije meseƒçni
        if (putnik.jePokupljen &&
            !putnik.jeOtkazan &&
            putnik.mesecnaKarta != true &&
            (putnik.iznosPlacanja == null || putnik.iznosPlacanja == 0)) {
          final pokupioVozac = putnik.pokupioVozac;
          if (pokupioVozac != null && vozaciStats.containsKey(pokupioVozac)) {
            vozaciStats[pokupioVozac]!['dugovi']++;
          }
        }
      }

      // 4. NAPLAƒÜENI I PAZAR - ko je NAPLATIO (po vremenu plaƒáanja) - SAMO OBIƒåNI PUTNICI
      if (_jePazarValjan(putnik) && putnik.vremePlacanja != null) {
        // üéØ ISKLJUƒåI MESEƒåNE PUTNIKE - isti kao u _calculateKombinovanPazarSync
        if (putnik.mesecnaKarta == true) continue;

        // Proveri da li je plaƒáen u datom periodu
        if (_jeUVremenskomOpsegu(
          putnik.vremePlacanja,
          normalizedFrom,
          normalizedTo,
        )) {
          // ‚úÖ SAMO REGISTROVANI VOZAƒåI: naplatioVozac > vozac (BEZ FALLBACK-a)
          final vozacIme = putnik.naplatioVozac ?? putnik.vozac!;
          if (vozaciStats.containsKey(vozacIme) &&
              VozacBoja.isValidDriver(vozacIme)) {
            vozaciStats[vozacIme]!['naplaceni']++;
            vozaciStats[vozacIme]!['pazarObicni'] += putnik.iznosPlacanja!;
            vozaciStats[vozacIme]!['ukupnoPazar'] += putnik.iznosPlacanja!;
          }
        }
      }
    }

    // üÜï DODAJ MESEƒåNE PUTNICE - KORISTI STVARNE PODATKE (GRUPE PO ID)
    // üí° GRUPIRAJ MESEƒåNE PUTNIKE PO ID - jedan meseƒçni putnik mo≈æe imati vi≈°e polazaka,
    // ali treba se raƒçunati samo jednom u statistike
    final Map<String, MesecniPutnik> uniqueMesecniPutnici = {};
    for (final putnik in mesecniPutnici) {
      uniqueMesecniPutnici[putnik.id] = putnik;
    }

    for (final putnik in uniqueMesecniPutnici.values) {
      if (putnik.jePlacen) {
        // ‚úÖ UNIFIKOVANA LOGIKA: koristi vremePlacanja umesto updatedAt
        // Proveri da li je meseƒçna karta plaƒáena u datom periodu
        if (putnik.vremePlacanja != null &&
            _jeUVremenskomOpsegu(
              putnik.vremePlacanja,
              normalizedFrom,
              normalizedTo,
            )) {
          // ‚úÖ SAMO REGISTROVANI VOZAƒåI za meseƒçne putnike (BEZ FALLBACK-a)
          final vozacIme = putnik.vozac!;
          if (vozaciStats.containsKey(vozacIme) &&
              VozacBoja.isValidDriver(vozacIme)) {
            // ‚úÖ MESEƒåNE KARTE SE DODAJU RAZDVOJENO
            vozaciStats[vozacIme]!['mesecneKarte']++;
            // ‚úÖ DODANO: meseƒçne karte se TAKOƒêER raƒçunaju u 'naplaceni' - ukupan broj naplaƒáenih
            vozaciStats[vozacIme]!['naplaceni']++;
            vozaciStats[vozacIme]!['pazarMesecne'] +=
                (putnik.iznosPlacanja ?? 0.0);
            vozaciStats[vozacIme]!['ukupnoPazar'] +=
                (putnik.iznosPlacanja ?? 0.0);
          }
        }
      }
    }

    // üöó DODAJ KILOMETRA≈ΩU ZA SVE VOZAƒåE
    await _dodajKilometrazu(vozaciStats, normalizedFrom, normalizedTo);

    return vozaciStats;
  }

  /// üîÑ REAL-TIME DETALJNE STATISTIKE STREAM ZA SVE VOZAƒåE
  static Stream<Map<String, Map<String, dynamic>>>
      streamDetaljneStatistikePoVozacima(DateTime from, DateTime to) {
    // Koristi kombinovani stream (putnici + meseƒçni putnici)
    return StreamZip([
      PutnikService().streamKombinovaniPutniciFiltered(),
      MesecniPutnikService.streamAktivniMesecniPutnici(),
    ]).map((data) {
      final putnici = data[0] as List<Putnik>;
      final mesecniPutnici = data[1] as List<MesecniPutnik>;
      return _calculateDetaljneStatistikeSinhronno(
        putnici,
        mesecniPutnici,
        from,
        to,
      );
    });
  }

  /// üîÑ PUBLIC SINHRONA KALKULACIJA DETALJNIH STATISTIKA (za external usage)
  static Map<String, Map<String, dynamic>> calculateDetaljneStatistikeSinhronno(
    List<Putnik> putnici,
    List<MesecniPutnik> mesecniPutnici,
    DateTime from,
    DateTime to,
  ) {
    return _calculateDetaljneStatistikeSinhronno(
      putnici,
      mesecniPutnici,
      from,
      to,
    );
  }

  /// üîÑ SINHRONA KALKULACIJA DETALJNIH STATISTIKA (za stream)
  static Map<String, Map<String, dynamic>>
      _calculateDetaljneStatistikeSinhronno(
    List<Putnik> putnici,
    List<MesecniPutnik> mesecniPutnici,
    DateTime from,
    DateTime to,
  ) {
    final normalizedFrom = _normalizeDateTime(from);
    final normalizedTo = _normalizeDateTime(to);

    final Map<String, Map<String, dynamic>> vozaciStats = {};

    // üéØ INICIJALIZUJ SVE VOZAƒåE SA NULAMA - DODANA POLJA ZA MESEƒåNE KARTE
    for (final vozac in sviVozaci) {
      vozaciStats[vozac] = {
        'dodati': 0,
        'otkazani': 0,
        'naplaceni': 0, // SAMO obiƒçni putnici
        'pokupljeni': 0,
        'dugovi': 0, // üÜï BROJ dugova (pokupljen ali nije plaƒáen)
        'ukupnoPazar': 0.0, // obiƒçni + meseƒçne karte
        'mesecneKarte': 0, // üÜï BROJ meseƒçnih karata
        'pazarObicni': 0.0, // üÜï PAZAR samo od obiƒçnih putnika
        'pazarMesecne': 0.0, // üÜï PAZAR samo od meseƒçnih karata
        'kilometraza': 0.0, // üöó KILOMETRA≈ΩA za taj dan
        'detaljiNaplata':
            <Map<String, dynamic>>[], // üÜï Lista detaljnih naplata
        'poslednjaNaplata': null, // üÜï Poslednja naplata
        'prosecanIznos': 0.0, // üÜï Proseƒçan iznos naplate
      };
    }

    // PROCESUIRAJ OBIƒåNE PUTNIKE
    for (final putnik in putnici) {
      if (putnik.vremeDodavanja != null) {
        if (_jeUVremenskomOpsegu(
          putnik.vremeDodavanja,
          normalizedFrom,
          normalizedTo,
        )) {
          final dodaoVozac = putnik.dodaoVozac ?? 'Nepoznat';
          if (vozaciStats.containsKey(dodaoVozac)) {
            vozaciStats[dodaoVozac]!['dodati']++;
          }
        }
      }

      // Proveri da li je otkazan u datom periodu
      if (putnik.jeOtkazan && putnik.vremeOtkazivanja != null) {
        if (_jeUVremenskomOpsegu(
          putnik.vremeOtkazivanja,
          normalizedFrom,
          normalizedTo,
        )) {
          final otkazaoVozac = putnik.otkazaoVozac ?? 'Nepoznat';
          if (vozaciStats.containsKey(otkazaoVozac)) {
            vozaciStats[otkazaoVozac]!['otkazani']++;
          }
        }
      }

      // Proveri da li je naplaƒáen u datom periodu
      if (_jePazarValjan(putnik) && putnik.vremePlacanja != null) {
        if (_jeUVremenskomOpsegu(
          putnik.vremePlacanja,
          normalizedFrom,
          normalizedTo,
        )) {
          // ‚úÖ SAMO REGISTROVANI VOZAƒåI: naplatioVozac > vozac (BEZ FALLBACK-a)
          final vozacIme = putnik.naplatioVozac ?? putnik.vozac!;
          if (vozaciStats.containsKey(vozacIme) &&
              VozacBoja.isValidDriver(vozacIme)) {
            final iznos = putnik.iznosPlacanja!;

            // Dodaj detalj naplate
            final detalj = {
              'ime': putnik.ime,
              'iznos': iznos,
              'vreme': putnik.vremePlacanja!.millisecondsSinceEpoch,
              'tip': putnik.mesecnaKarta == true ? 'Meseƒçna' : 'Dnevna',
            };

            (vozaciStats[vozacIme]!['detaljiNaplata']
                    as List<Map<String, dynamic>>)
                .add(detalj);

            // A≈æuriraj poslednju naplatu
            if (vozaciStats[vozacIme]!['poslednjaNaplata'] == null ||
                putnik.vremePlacanja!.isAfter(
                  DateTime.fromMillisecondsSinceEpoch(
                    vozaciStats[vozacIme]!['poslednjaNaplata']['vreme'] as int,
                  ),
                )) {
              vozaciStats[vozacIme]!['poslednjaNaplata'] = detalj;
            }

            // ‚ùå MESEƒåNE KARTE SE NE RAƒåUNAJU U 'naplaceni' - to je samo za obiƒçne putnike
            if (putnik.mesecnaKarta != true) {
              vozaciStats[vozacIme]!['naplaceni']++;
              vozaciStats[vozacIme]!['pazarObicni'] += iznos;
              vozaciStats[vozacIme]!['ukupnoPazar'] += iznos;
            }
          }
        }
      }

      // Proveri da li je pokupljen u datom periodu
      if (putnik.vremePokupljenja != null) {
        if (_jeUVremenskomOpsegu(
          putnik.vremePokupljenja,
          normalizedFrom,
          normalizedTo,
        )) {
          final pokupioVozac = putnik.pokupioVozac;
          if (pokupioVozac != null && vozaciStats.containsKey(pokupioVozac)) {
            vozaciStats[pokupioVozac]!['pokupljeni']++;
          }
        }
      }

      // üÜï DUGOVI (SINHRONO) - pokupljen ali nije plaƒáen, nije otkazan, nije meseƒçni
      if (putnik.jePokupljen &&
          !putnik.jeOtkazan &&
          putnik.mesecnaKarta != true &&
          (putnik.iznosPlacanja == null || putnik.iznosPlacanja == 0)) {
        if (putnik.vremePokupljenja != null) {
          if (_jeUVremenskomOpsegu(
            putnik.vremePokupljenja,
            normalizedFrom,
            normalizedTo,
          )) {
            final pokupioVozac = putnik.dodaoVozac ?? 'Nepoznat';
            if (vozaciStats.containsKey(pokupioVozac)) {
              vozaciStats[pokupioVozac]!['dugovi']++;
            }
          }
        }
      }
    }

    // üÜï DODAJ MESEƒåNE KARTE - KORISTI STVARNE PODATKE (SINHRONO) SA GRUPIRANJEM

    // üé´ GRUPIRANJE MESEƒåNIH PUTNIKA PO IMENU (isto kao u streamPazarSvihVozaca)
    final Map<String, MesecniPutnik> grupisaniMesecniPutnici = {};

    // ÔøΩ FIX: KORISTI PROSLEƒêENI OPSEG (from/to) umesto hardkodovanog meseƒçnog opsega
    // Ovo omoguƒáava filtriranje meseƒçnih karata za godi≈°nji period
    final mesecniFrom = normalizedFrom;
    final mesecniTo = normalizedTo;

    for (final putnik in mesecniPutnici) {
      if (putnik.jePlacen) {
        // ‚úÖ MESEƒåNE KARTE: koristi MESEƒåNI opseg umesto sedmiƒçnog/dnevnog
        // Proveri da li je meseƒçna karta plaƒáena u OVOM MESECU
        if (putnik.vremePlacanja != null &&
            _jeUVremenskomOpsegu(
              putnik.vremePlacanja,
              mesecniFrom,
              mesecniTo,
            )) {
          // üé´ GRUPIRANJE: Dodaj samo prvi polazak po imenu (putnikIme)
          final kljuc = putnik.putnikIme.trim();
          if (!grupisaniMesecniPutnici.containsKey(kljuc)) {
            grupisaniMesecniPutnici[kljuc] = putnik;
          }
        } else {
          // DEBUG: Za≈°to se Ana Cortan ne ukljuƒçuje?
          if (putnik.putnikIme.toLowerCase().contains('ana')) {
            print(
              'üîç DEBUG Ana Cortan: jePlacen=${putnik.jePlacen}, vremePlacanja=${putnik.vremePlacanja}, mesecniFrom=$mesecniFrom, mesecniTo=$mesecniTo',
            );
            if (putnik.vremePlacanja != null) {
              final uOpsegu = _jeUVremenskomOpsegu(
                putnik.vremePlacanja,
                mesecniFrom,
                mesecniTo,
              );
              print('üîç DEBUG Ana Cortan u opsegu: $uOpsegu');
            }
          }
        }
      } else {
        // DEBUG: Ana nije plaƒáena?
        if (putnik.putnikIme.toLowerCase().contains('ana')) {
          print(
            'üîç DEBUG Ana Cortan NIJE PLAƒÜENA: jePlacen=${putnik.jePlacen}, cena=${putnik.cena}',
          );
        }
      }
    }

    // üé´ PROCES GRUPISANIH MESEƒåNIH PUTNIKA
    for (final putnik in grupisaniMesecniPutnici.values) {
      final vozacIme =
          putnik.vozac ?? 'Nepoznat'; // ‚úÖ KORISTI vozac umesto naplatioVozac
      if (vozaciStats.containsKey(vozacIme)) {
        final iznos = putnik.iznosPlacanja ?? 0.0;

        // Dodaj detalj naplate za meseƒçnu kartu
        if (putnik.vremePlacanja != null) {
          final detalj = {
            'ime': putnik.putnikIme,
            'iznos': iznos,
            'vreme': putnik.vremePlacanja!.millisecondsSinceEpoch,
            'tip': 'Meseƒçna',
          };

          (vozaciStats[vozacIme]!['detaljiNaplata']
                  as List<Map<String, dynamic>>)
              .add(detalj);

          // A≈æuriraj poslednju naplatu
          if (vozaciStats[vozacIme]!['poslednjaNaplata'] == null ||
              putnik.vremePlacanja!.isAfter(
                DateTime.fromMillisecondsSinceEpoch(
                  vozaciStats[vozacIme]!['poslednjaNaplata']['vreme'] as int,
                ),
              )) {
            vozaciStats[vozacIme]!['poslednjaNaplata'] = detalj;
          }
        }

        // ‚úÖ MESEƒåNE KARTE SE DODAJU I U 'naplaceni' I U 'mesecneKarte'
        vozaciStats[vozacIme]!['naplaceni']++; // ‚úÖ DODANO
        vozaciStats[vozacIme]!['mesecneKarte']++;
        vozaciStats[vozacIme]!['pazarMesecne'] += iznos;
        vozaciStats[vozacIme]!['ukupnoPazar'] += iznos;
      }
    }

    // üöó DODAJ KILOMETRA≈ΩU ZA SVE VOZAƒåE (SINHRONO - upro≈°ƒáeno)
    try {
      // Za real-time stream, koristimo upro≈°ƒáenu kilometra≈æu bez database poziva
      // jer bi to bilo previ≈°e sporo za real-time azuriranje
      for (final vozac in sviVozaci) {
        vozaciStats[vozac]!['kilometraza'] =
            0.0; // Default vrednost za real-time
      }
    } catch (e) {
      // ignore: empty_catches
    }

    // üßÆ KALKULI≈†I PROSEƒåNE IZNOSE ZA SVE VOZAƒåE
    for (final vozac in sviVozaci) {
      final detalji =
          vozaciStats[vozac]!['detaljiNaplata'] as List<Map<String, dynamic>>;
      if (detalji.isNotEmpty) {
        final ukupanIznos = detalji.fold<double>(
          0.0,
          (sum, detalj) => sum + (detalj['iznos'] as num).toDouble(),
        );
        vozaciStats[vozac]!['prosecanIznos'] = ukupanIznos / detalji.length;
      }
    }

    return vozaciStats;
  }

  /// üéØ PAZAR SAMO OD PUTNIKA - BEZ MESEƒåNIH KARATA (za admin screen filtriranje po danu)
  static Map<String, double> pazarSamoPutnici(List<Putnik> putnici) {
    // üéØ DINAMIƒåKA INICIJALIZACIJA VOZAƒåA
    final Map<String, double> pazar = {};
    for (final vozac in sviVozaci) {
      pazar[vozac] = 0.0;
    }

    // SABERI PAZAR SAMO IZ PUTNIKA
    for (final putnik in putnici) {
      if (_jePazarValjan(putnik)) {
        final vozac = putnik.vozac!;
        if (pazar.containsKey(vozac)) {
          pazar[vozac] = pazar[vozac]! + putnik.iznosPlacanja!;
        }
      }
    }

    return {...pazar, '_ukupno': pazar.values.fold(0.0, (a, b) => a + b)};
  }

  /// Vraca mapu: {imeVozaca: sumaPazara} i ukupno, za dati period - STANDARDIZOVANO FILTRIRANJE
  /// @deprecated Koristi pazarSvihVozaca() umesto ovoga za konzistentnost
  static Future<Map<String, double>> pazarPoVozacima(
    List<Putnik> putnici,
    DateTime from,
    DateTime to,
  ) async {
    // Preusmeri na novu standardizovanu funkciju
    return await pazarSvihVozaca(putnici, from: from, to: to);
  }

  // üöó KILOMETRA≈ΩA FUNKCIJE

  /// Dodaje kilometra≈æu za sve vozaƒçe u vozaciStats
  static Future<void> _dodajKilometrazu(
    Map<String, Map<String, dynamic>> vozaciStats,
    DateTime from,
    DateTime to,
  ) async {
    try {
      // ‚úÖ OPTIMIZACIJA: ograniƒçi opseg na maksimalno 7 dana da ne bude previ≈°e sporo
      const limitOpseg = Duration(days: 7);
      final opsegDana = to.difference(from);

      if (opsegDana > limitOpseg) {
        from = to.subtract(limitOpseg);
      }

      for (final vozac in sviVozaci) {
        final km = await _kmZaVozaca(vozac, from, to);
        vozaciStats[vozac]!['kilometraza'] = km;
      }
    } catch (e) {
      // Dodeli default vrednosti ako je gre≈°ka
      for (final vozac in sviVozaci) {
        vozaciStats[vozac]!['kilometraza'] = 0.0;
      }
    }
  }

  /// Raƒçuna kilometra≈æu za vozaƒça u datom periodu (SA PAMETNIM FILTRIRANJEM)
  static Future<double> _kmZaVozaca(
    String vozac,
    DateTime from,
    DateTime to,
  ) async {
    try {
      final response = await Supabase.instance.client
          .from('gps_lokacije')
          .select()
          .eq('vozac_id', vozac) // ‚úÖ Ispravljen naziv kolone
          .gte('vreme', from.toIso8601String()) // ‚úÖ Ispravljen naziv kolone
          .lte('vreme', to.toIso8601String()) // ‚úÖ Ispravljen naziv kolone
          .order('vreme');

      final lokacije = (response as List).cast<Map<String, dynamic>>();

      if (lokacije.length < 2) return 0.0;

      double ukupno = 0;
      double maksimalnaDistancaPoSegmentu = 5.0; // 5km max po segmentu

      for (int i = 1; i < lokacije.length; i++) {
        final lat1 = (lokacije[i - 1]['latitude'] as num)
            .toDouble(); // ‚úÖ Ispravljen naziv
        final lng1 = (lokacije[i - 1]['longitude'] as num)
            .toDouble(); // ‚úÖ Ispravljen naziv
        final lat2 =
            (lokacije[i]['latitude'] as num).toDouble(); // ‚úÖ Ispravljen naziv
        final lng2 =
            (lokacije[i]['longitude'] as num).toDouble(); // ‚úÖ Ispravljen naziv

        final distanca = _distanceKm(lat1, lng1, lat2, lng2);

        // ‚úÖ PAMETAN FILTER: preskoƒçi nerealne distanca (npr. GPS gre≈°ke)
        if (distanca <= maksimalnaDistancaPoSegmentu && distanca > 0.001) {
          ukupno += distanca;
        } else if (distanca > maksimalnaDistancaPoSegmentu) {}
      }
      return ukupno;
    } catch (e) {
      return 0.0;
    }
  }

  /// ÔøΩ JAVNA METODA: Dobij kilometra≈æu za vozaƒça u odreƒëenom periodu
  static Future<double> getKilometrazu(
    String vozac,
    DateTime from,
    DateTime to,
  ) async {
    return await _kmZaVozaca(vozac, from, to);
  }

  /// ÔøΩüîÑ RESETUJ SVE KILOMETRA≈ΩE NA 0 - bri≈°e sve GPS pozicije
  static Future<bool> resetujSveKilometraze() async {
    try {
      final supabase = Supabase.instance.client;

      // Obri≈°i sve GPS pozicije iz tabele
      await supabase
          .from('gps_lokacije')
          .delete()
          .neq('id', 0); // Bri≈°e sve redove (neq sa nepostojeƒáim ID)
      return true;
    } catch (e) {
      return false;
    }
  }

  /// üí∞ RESETUJ PAZAR ZA ODREƒêENOG VOZAƒåA - bri≈°e podatke o naplatama
  static Future<bool> resetujPazarZaVozaca(
    String vozac, {
    DateTime? from,
    DateTime? to,
  }) async {
    try {
      final now = _normalizeDateTime(DateTime.now());
      final fromDate = from ?? DateTime(now.year, now.month, now.day);
      final toDate = to ?? DateTime(now.year, now.month, now.day, 23, 59, 59);

      final supabase = Supabase.instance.client;

      // 1. RESETUJ OBIƒåNE PUTNIKE - (upit ka tabeli 'putnici' uklonjen po zahtevu)
      // Ova sekcija je prazna jer tabela 'putnici' vi≈°e nije u upotrebi.

      // 2. RESETUJ MESEƒåNE KARTE - postavi cena na 0 i obri≈°i vreme_placanja
      try {
        await supabase
            .from('mesecni_putnici')
            .update({
              'cena': 0.0,
              'vreme_placanja': null,
            })
            .eq('vozac', vozac)
            .not('vreme_placanja', 'is', null)
            .gte('vreme_placanja', fromDate.toIso8601String())
            .lte('vreme_placanja', toDate.toIso8601String());
      } catch (e) {
        // ignore: empty_catches
      }
      return true;
    } catch (e) {
      return false;
    }
  }

  /// üí∞ RESETUJ SAMO DANAS PAZAR ZA VOZAƒåA - br≈æi reset za dana≈°nji dan
  static Future<bool> resetujDanasPazarZaVozaca(String vozac) async {
    final now = DateTime.now();
    final danasStart = DateTime(now.year, now.month, now.day);
    final danasEnd = DateTime(now.year, now.month, now.day, 23, 59, 59);

    return await resetujPazarZaVozaca(vozac, from: danasStart, to: danasEnd);
  }

  /// üö® RESETUJ PAZAR ZA SVE VOZAƒåE - bri≈°e SVE podatke o naplatama za sve vozaƒçe
  static Future<bool> resetujPazarZaSveVozace({
    DateTime? from,
    DateTime? to,
  }) async {
    List<String> neuspesniVozaci = [];

    for (String vozac in sviVozaci) {
      try {
        bool uspeh = await resetujPazarZaVozaca(vozac, from: from, to: to);
        if (!uspeh) {
          neuspesniVozaci.add(vozac);
        }
      } catch (e) {
        neuspesniVozaci.add(vozac);
      }
    }
    if (neuspesniVozaci.isNotEmpty) {}

    return neuspesniVozaci.isEmpty;
  }

  /// üö® RESETUJ DANA≈†NJI PAZAR ZA SVE VOZAƒåE - br≈æi reset samo za dana≈°nji dan
  static Future<bool> resetujDanasPazarZaSveVozace() async {
    final now = DateTime.now();
    final danasStart = DateTime(now.year, now.month, now.day);
    final danasEnd = DateTime(now.year, now.month, now.day, 23, 59, 59);

    return await resetujPazarZaSveVozace(from: danasStart, to: danasEnd);
  }

  /// üö® NUKLEARNI RESET - bri≈°e SVE podatke o naplatama za sve vozaƒçe (cela istorija!)
  static Future<bool> nuklearniResetSvihPazara() async {
    return await resetujPazarZaSveVozace(); // Bez from/to parametara = bri≈°e sve
  }

  /// Raƒçuna rastojanje izmeƒëu dve GPS koordinate u kilometrima (Haversine formula)
  static double _distanceKm(
    double lat1,
    double lon1,
    double lat2,
    double lon2,
  ) {
    const double R = 6371; // Radius Zemlje u km
    double dLat = (lat2 - lat1) * pi / 180.0;
    double dLon = (lon2 - lon1) * pi / 180.0;
    double a = 0.5 -
        cos(dLat) / 2 +
        cos(lat1 * pi / 180.0) * cos(lat2 * pi / 180.0) * (1 - cos(dLon)) / 2;
    return R * 2 * asin(sqrt(a));
  }

  // üÜï CLEAN STATISTIKE METODE - bez duplikata

  /// Dohvati clean statistike bez duplikata
  static Future<Map<String, dynamic>> dohvatiCleanStatistike() async {
    try {
      return await CleanStatistikaService.dohvatiUkupneStatistike();
    } catch (e) {
      dlog('Gre≈°ka pri dohvatanju clean statistika: $e');
      rethrow;
    }
  }

  /// Proveri da li podaci nemaju duplikate
  static Future<bool> proveriBezDuplikata() async {
    try {
      final stats = await CleanStatistikaService.dohvatiUkupneStatistike();
      return stats['no_duplicates'] as bool;
    } catch (e) {
      dlog('Gre≈°ka pri proveri duplikata: $e');
      return false;
    }
  }

  /// Dohvati clean meseƒçne statistike bez duplikata
  static Future<Map<String, dynamic>> getCleanMesecneStatistike(
    int mesec,
    int godina,
  ) async {
    try {
      return await CleanStatistikaService.dohvatiMesecneStatistike(
        mesec,
        godina,
      );
    } catch (e) {
      dlog('Gre≈°ka pri dohvatanju clean meseƒçnih statistika: $e');
      rethrow;
    }
  }

  /// Dohvati clean listu svih putnika bez duplikata
  static Future<List<Map<String, dynamic>>> dohvatiCleanSvePutnike() async {
    try {
      return await CleanStatistikaService.dohvatiSvePutnikeClean();
    } catch (e) {
      dlog('Gre≈°ka pri dohvatanju clean liste putnika: $e');
      rethrow;
    }
  }

  /// Dohvati clean ukupan iznos bez duplikata
  static Future<double> dohvatiCleanUkupanIznos() async {
    try {
      final stats = await CleanStatistikaService.dohvatiUkupneStatistike();
      return (stats['ukupno_sve'] as num).toDouble();
    } catch (e) {
      dlog('Gre≈°ka pri dohvatanju clean ukupnog iznosa: $e');
      rethrow;
    }
  }

  /// Debug informacije za clean statistike
  static Future<Map<String, dynamic>> cleanDebugInfo() async {
    try {
      final stats = await CleanStatistikaService.dohvatiUkupneStatistike();
      final actualAmount = (stats['ukupno_sve'] as num).toDouble();

      return {
        'timestamp': DateTime.now().toIso8601String(),
        'service': 'StatistikaService.cleanDebugInfo -> CleanStatistikaService',
        'clean_stats': stats,
        'validation': {
          'no_duplicates': stats['no_duplicates'],
          'actual_amount': actualAmount,
          'total_records': stats['broj_ukupno'],
          'mesecni_records': stats['broj_mesecnih'],
          'standalone_records': stats['broj_standalone'],
        },
      };
    } catch (e) {
      dlog('Gre≈°ka pri debug info clean statistika: $e');
      rethrow;
    }
  }
}

import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../utils/logging.dart';
import '../services/vozac_registracija_service.dart';

class PhoneAuthService {
  static final _supabase = Supabase.instance.client;

  // Brojevi telefona za vozaƒçe
  static const Map<String, String> _driverPhones = {
    'Bojan': '+381641162560',
    'Bruda': '+381641202844',
    'Svetlana': '+381658464160',
    'Bilevski': '+381641234567', // Test broj za Bilevskog
  };

  /// Helper funkcija za dobijanje imena vozaƒça po broju telefona
  static String? _getDriverNameByPhone(String phoneNumber) {
    for (final entry in _driverPhones.entries) {
      if (entry.value == phoneNumber) {
        return entry.key;
      }
    }
    return null;
  }

  /// üì® PO≈†ALJI SMS KOD (sa fallback za lokalni development)
  static Future<bool> sendSMSCode(String phoneNumber) async {
    try {
      // LOKALNI DEVELOPMENT - simulacija slanja SMS-a (usklaƒëeno sa config.toml)
      const Map<String, String> testOTPCodes = {
        '+381641162560': '123456', // Bojan
        '+381641202844': '123456', // Bruda
        '+381658464160': '123456', // Svetlana
        '+381641234567': '123456', // Bilevski
      };

      if (testOTPCodes.containsKey(phoneNumber)) {
        dlog(
            '‚úÖ DEVELOPMENT: Simuliram SMS kod ${testOTPCodes[phoneNumber]} za: $phoneNumber');
        // U realnom development-u, ovde bi trebalo prikazati kod u UI
        return true;
      }

      // Poku≈°aj sa pravim Supabase SMS servisom
      try {
        await _supabase.auth.signInWithOtp(phone: phoneNumber);
        dlog('‚úÖ Pravi SMS kod poslan na: $phoneNumber');
        return true;
      } catch (e) {
        dlog('‚ö†Ô∏è Pravi SMS servis nije dostupan: $e');
        // Fallback na test kodove za poznate brojeve
        if (testOTPCodes.containsKey(phoneNumber)) {
          dlog('‚úÖ FALLBACK: Koristim test kod za: $phoneNumber');
          return true;
        }
        throw e;
      }
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri slanju SMS koda: $e');
      return false;
    }
  }

  /// üì± DOBIJ TEST OTP KOD ZA BROJ (za development)
  static String? getTestOTPCode(String phoneNumber) {
    const Map<String, String> testOTPCodes = {
      '+381641162560': '123456', // Bojan
      '+381641202844': '123456', // Bruda
      '+381658464160': '123456', // Svetlana
      '+381641234567': '123456', // Bilevski
    };
    return testOTPCodes[phoneNumber];
  }

  /// üì® PROVERI DA LI JE POZNATI TEST BROJ (za development UI)
  static bool isKnownTestNumber(String phoneNumber) {
    const Map<String, String> testOTPCodes = {
      '+381641162560': '123456', // Bojan
      '+381641202844': '123456', // Bruda
      '+381658464160': '123456', // Svetlana
      '+381641234567': '123456', // Bilevski
    };
    return testOTPCodes.containsKey(phoneNumber);
  }

  /// üß™ DOBIJ DEVELOPMENT PORUKU ZA UI
  static String? getTestCodeMessage(String phoneNumber) {
    final testCode = getTestOTPCode(phoneNumber);
    final driverName = _getDriverNameByPhone(phoneNumber);

    if (testCode != null && driverName != null) {
      return "DEVELOPMENT: Test kod za $driverName je: $testCode";
    }
    return null;
  }

  /// üì® POTVRDI SMS KOD (sa fallback za lokalni development)
  static Future<bool> confirmSMSVerification(
      String phoneNumber, String smsCode) async {
    try {
      dlog('üì® Potvrƒëujem broj: $phoneNumber sa SMS kodom: $smsCode');

      // LOKALNI DEVELOPMENT FALLBACK - test kodovi (usklaƒëeno sa config.toml)
      const Map<String, String> testOTPCodes = {
        '+381641162560': '123456', // Bojan
        '+381641202844': '123456', // Bruda
        '+381658464160': '123456', // Svetlana
        '+381641234567': '123456', // Bilevski
      };

      // Provebi da li je test kod
      if (testOTPCodes.containsKey(phoneNumber) &&
          testOTPCodes[phoneNumber] == smsCode) {
        dlog('‚úÖ Test SMS kod potvrƒëen za: $phoneNumber');

        // A≈æuriraj lokalne podatke
        await _updateSMSConfirmationStatus(phoneNumber, true);

        // Registruj vozaƒça kao SMS potvrƒëenog
        final driverName = _getDriverNameByPhone(phoneNumber);
        if (driverName != null) {
          await VozacRegistracijaService.oznaciVozacaKaoRegistrovanog(
              driverName);
        }

        return true;
      }

      // Poku≈°aj sa pravim Supabase SMS servisom
      try {
        final AuthResponse response = await _supabase.auth.verifyOTP(
          type: OtpType.sms,
          token: smsCode,
          phone: phoneNumber,
        );

        if (response.user != null && response.user!.phoneConfirmedAt != null) {
          dlog('‚úÖ Pravi SMS uspje≈°no potvrƒëen za: $phoneNumber');

          // A≈æuriraj lokalne podatke
          await _updateSMSConfirmationStatus(phoneNumber, true);

          return true;
        }
      } catch (e) {
        dlog('‚ö†Ô∏è Pravi SMS servis nije dostupan: $e');
      }

      dlog('‚ùå SMS potvrda neuspje≈°na za: $phoneNumber');
      return false;
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri potvrdi SMS: $e');
      return false;
    }
  }

  /// üîê PRIJAVI SE SA BROJEM I ≈†IFROM
  static Future<String?> signInWithPhone(
      String phoneNumber, String password) async {
    try {
      dlog('üîê Prijavljivanje sa brojem: $phoneNumber');

      final AuthResponse response = await _supabase.auth.signInWithPassword(
        phone: phoneNumber,
        password: password,
      );

      if (response.user != null) {
        // Provjeri da li je broj potvrƒëen
        if (response.user!.phoneConfirmedAt == null) {
          dlog('‚ö†Ô∏è Broj telefona nije potvrƒëen za: $phoneNumber');
          return null;
        }

        // Izvuci ime vozaƒça iz metapodataka
        final driverName =
            response.user!.userMetadata?['driver_name'] as String?;

        if (driverName != null) {
          dlog('‚úÖ Uspje≈°na prijava vozaƒça: $driverName');

          // Saƒçuvaj trenutnu sesiju
          await _saveCurrentSession(driverName, phoneNumber);

          return driverName;
        } else {
          dlog('‚ùå Nije pronaƒëeno ime vozaƒça u metapodacima');
          return null;
        }
      } else {
        dlog('‚ùå Neuspje≈°na prijava za broj: $phoneNumber');
        return null;
      }
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri prijavi: $e');
      return null;
    }
  }

  /// üö™ ODJAVI SE
  static Future<bool> signOut() async {
    try {
      await _supabase.auth.signOut();
      await _clearCurrentSession();
      dlog('‚úÖ Uspje≈°na odjava');
      return true;
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri odjavi: $e');
      return false;
    }
  }

  /// üì¨ PO≈†ALJI PONOVO SMS KOD (sa fallback za lokalni development)
  static Future<bool> resendSMSCode(String phoneNumber) async {
    try {
      // LOKALNI DEVELOPMENT - simulacija ponovnog slanja SMS-a
      const Map<String, String> testOTPCodes = {
        '+381641162560': '123456', // Bojan
        '+381641202844': '123456', // Bruda
        '+381658464160': '123456', // Svetlana
        '+381641234567': '123456', // Bilevski
      };

      if (testOTPCodes.containsKey(phoneNumber)) {
        dlog(
            '‚úÖ DEVELOPMENT: Simuliram ponovno slanje SMS koda ${testOTPCodes[phoneNumber]} za: $phoneNumber');
        return true;
      }

      // Poku≈°aj sa pravim Supabase SMS servisom
      try {
        await _supabase.auth.resend(
          type: OtpType.sms,
          phone: phoneNumber,
        );
        dlog('‚úÖ Pravi SMS kod ponovno poslan na: $phoneNumber');
        return true;
      } catch (e) {
        dlog('‚ö†Ô∏è Pravi SMS servis nije dostupan: $e');
        // Fallback na test kodove za poznate brojeve
        if (testOTPCodes.containsKey(phoneNumber)) {
          dlog('‚úÖ FALLBACK: Koristim test kod za: $phoneNumber');
          return true;
        }
        throw e;
      }
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri slanju SMS koda: $e');
      return false;
    }
  }

  /// üîë RESETUJ ≈†IFRU PREKO SMS-a
  static Future<bool> resetPasswordViaSMS(String phoneNumber) async {
    try {
      // Koristimo signInWithOtp za reset - ≈°aljemo novi kod
      await _supabase.auth.signInWithOtp(
        phone: phoneNumber,
      );
      dlog('‚úÖ SMS za reset ≈°ifre poslan na: $phoneNumber');
      return true;
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri slanju SMS za reset ≈°ifre: $e');
      return false;
    }
  }

  /// ‚úÖ PROVJERI DA LI JE VOZAƒå REGISTROVAN I POTVRƒêEN
  static Future<bool> isDriverPhoneRegisteredAndConfirmed(
      String driverName) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final isConfirmed = prefs.getBool('phone_confirmed_$driverName') ?? false;
      return isConfirmed;
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri provjeri registracije broja: $e');
      return false;
    }
  }

  /// üìã DOHVATI PODATKE O TRENUTNOJ SESIJI
  static Future<Map<String, String>?> getCurrentSession() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final driverName = prefs.getString('current_session_driver');
      final phoneNumber = prefs.getString('current_session_phone');

      if (driverName != null && phoneNumber != null) {
        return {
          'driver_name': driverName,
          'phone_number': phoneNumber,
        };
      }
      return null;
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri dohvatanju trenutne sesije: $e');
      return null;
    }
  }

  /// üì± DOHVATI BROJ TELEFONA ZA VOZAƒåA
  static String? getDriverPhone(String driverName) {
    return _driverPhones[driverName];
  }

  /// üì± FORMATIRAJ BROJ TELEFONA
  static String formatPhoneNumber(String phoneNumber) {
    if (phoneNumber.startsWith('+')) {
      return phoneNumber;
    } else {
      return '+381$phoneNumber';
    }
  }

  /// üìú DOHVATI SVE VOZAƒåE KOJI MOGU DA SE REGISTRUJU
  static List<String> getAllDriversForRegistration() {
    return _driverPhones.keys.toList();
  }

  /// üìû VALIDIRAJ FORMAT BROJA TELEFONA
  static bool isValidPhoneFormat(String phoneNumber) {
    // Provjeri da li je u formatu +381XXXXXXXXX
    final phoneRegex = RegExp(r'^\+381[0-9]{8,9}$');
    return phoneRegex.hasMatch(phoneNumber);
  }

  /// üì± REGISTRUJ VOZAƒåA SA TELEFONOM/SMS
  static Future<bool> registerDriverWithPhone(
      String driverName, String phoneNumber, String password) async {
    try {
      dlog('üì± Registrujem vozaƒça $driverName sa telefonom: $phoneNumber');

      // Proveri da li je broj telefona valjan za ovog vozaƒça
      final expectedPhone = getDriverPhone(driverName);
      if (expectedPhone == null || expectedPhone != phoneNumber) {
        dlog('‚ùå Nevaljan broj telefona za vozaƒç $driverName');
        return false;
      }

      // Po≈°alji SMS kod
      final codeSent = await sendSMSCode(phoneNumber);
      if (!codeSent) {
        dlog('‚ùå Slanje SMS koda neuspe≈°no');
        return false;
      }

      // Saƒçuvaj podatke za registraciju (ƒçeka SMS verifikaciju)
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('pending_registration_driver', driverName);
      await prefs.setString('pending_registration_phone', phoneNumber);
      await prefs.setString('pending_registration_password', password);
      await prefs.setBool('is_pending_registration', true);

      dlog('‚úÖ SMS registracija u toku za $driverName, ƒçeka se verifikacija');
      return true;
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri registraciji vozaƒça $driverName sa telefonom: $e');
    }
    return false;
  }

  /// üì± ZAVR≈†I SMS REGISTRACIJU NAKON VERIFIKACIJE
  static Future<bool> completePhoneRegistration(String smsCode) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final driverName = prefs.getString('pending_registration_driver');
      final phoneNumber = prefs.getString('pending_registration_phone');
      final password = prefs.getString('pending_registration_password');

      if (driverName == null || phoneNumber == null || password == null) {
        dlog('‚ùå Nedostaju podaci za zavr≈°etak registracije');
        return false;
      }

      // Verifikuj SMS kod putem Supabase
      final AuthResponse response = await _supabase.auth.verifyOTP(
        phone: phoneNumber,
        token: smsCode,
        type: OtpType.sms,
      );

      if (response.user == null) {
        dlog('‚ùå Nevaljan SMS kod');
        return false;
      }

      // Registracija uspe≈°na - saƒçuvaj konaƒçne podatke
      await prefs.setString('registered_driver', driverName);
      await prefs.setString('driver_phone', phoneNumber);
      await prefs.setBool('is_driver_registered', true);
      await prefs.setBool('is_phone_verified', true);
      await prefs.setString('vozac_ime', driverName);

      // Oznaƒçi vozaƒça kao registrovanog u VozacRegistracijaService
      await VozacRegistracijaService.oznaciVozacaKaoRegistrovanog(driverName);

      // Ukloni privremene podatke
      await prefs.remove('pending_registration_driver');
      await prefs.remove('pending_registration_phone');
      await prefs.remove('pending_registration_password');
      await prefs.setBool('is_pending_registration', false);

      dlog('‚úÖ SMS registracija zavr≈°ena uspe≈°no za vozaƒç: $driverName');
      return true;
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri zavr≈°etku SMS registracije: $e');
    }
    return false;
  }

  /// üìß REGISTRUJ VOZAƒåA SA EMAIL-OM
  static Future<bool> registerDriverWithEmail(
      String driverName, String email, String password) async {
    try {
      dlog('üìß Registrujem vozaƒça $driverName sa email-om: $email');

      final AuthResponse response =
          await _supabase.auth.signUp(email: email, password: password, data: {
        'driver_name': driverName,
        'role': 'driver',
        'auth_type': 'email',
        'registered_at': DateTime.now().toIso8601String(),
      });

      if (response.user != null) {
        dlog(
            '‚úÖ Vozaƒç $driverName uspje≈°no registrovan sa email-om. ƒåeka se email potvrda.');

        // Saƒçuvaj podatke lokalno
        await _saveDriverEmailData(driverName, email);

        return true;
      } else {
        dlog('‚ùå Registracija neuspje≈°na za $driverName');
        return false;
      }
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri registraciji vozaƒça $driverName sa email-om: $e');
      return false;
    }
  }

  /// üìß POTVRDI EMAIL VERIFIKACIJU
  static Future<bool> confirmEmailVerification(
      String email, String emailCode) async {
    try {
      dlog('üìß Potvrƒëujem email: $email sa kodom: $emailCode');

      final AuthResponse response = await _supabase.auth.verifyOTP(
        type: OtpType.email,
        token: emailCode,
        email: email,
      );

      if (response.user != null && response.user!.emailConfirmedAt != null) {
        dlog('‚úÖ Email uspje≈°no potvrƒëen za: $email');

        // A≈æuriraj lokalne podatke
        await _updateEmailConfirmationStatus(email, true);

        return true;
      } else {
        dlog('‚ùå Email potvrda neuspje≈°na za: $email');
        return false;
      }
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri potvrdi email-a: $e');
      return false;
    }
  }

  /// üîê PRIJAVI SE SA EMAIL-OM I ≈†IFROM
  static Future<String?> signInWithEmail(String email, String password) async {
    try {
      dlog('üîê Prijavljivanje sa email-om: $email');

      final AuthResponse response = await _supabase.auth.signInWithPassword(
        email: email,
        password: password,
      );

      if (response.user != null) {
        // Provjeri da li je email potvrƒëen
        if (response.user!.emailConfirmedAt == null) {
          dlog('‚ö†Ô∏è Email nije potvrƒëen za: $email');
          return null;
        }

        // Izvuci ime vozaƒça iz metapodataka
        final driverName =
            response.user!.userMetadata?['driver_name'] as String?;

        if (driverName != null) {
          dlog('‚úÖ Uspje≈°na prijava vozaƒça: $driverName sa email-om');

          // Saƒçuvaj trenutnu sesiju
          await _saveCurrentEmailSession(driverName, email);

          return driverName;
        } else {
          dlog('‚ùå Nije pronaƒëeno ime vozaƒça u metapodacima');
          return null;
        }
      } else {
        dlog('‚ùå Neuspje≈°na prijava za email: $email');
        return null;
      }
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri prijavi sa email-om: $e');
      return null;
    }
  }

  /// üìß PO≈†ALJI PONOVO EMAIL KOD
  static Future<bool> resendEmailCode(String email) async {
    try {
      await _supabase.auth.resend(
        type: OtpType.email,
        email: email,
      );
      dlog('‚úÖ Email kod ponovno poslan na: $email');
      return true;
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri slanju email koda: $e');
      return false;
    }
  }

  /// üîë RESETUJ ≈†IFRU PREKO EMAIL-a
  static Future<bool> resetPasswordViaEmail(String email) async {
    try {
      await _supabase.auth.resetPasswordForEmail(email);
      dlog('‚úÖ Email za reset ≈°ifre poslan na: $email');
      return true;
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri slanju email-a za reset ≈°ifre: $e');
      return false;
    }
  }

  /// ‚úÖ PROVJERI DA LI JE VOZAƒå REGISTROVAN I POTVRƒêEN SA EMAIL-OM
  static Future<bool> isDriverEmailRegisteredAndConfirmed(
      String driverName) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final isConfirmed = prefs.getBool('email_confirmed_$driverName') ?? false;
      return isConfirmed;
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri provjeri registracije email-a: $e');
      return false;
    }
  }

  /// üìß DOHVATI EMAIL ZA VOZAƒåA
  static Future<String?> getDriverEmail(String driverName) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      return prefs.getString('driver_email_$driverName');
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri dohvatanju email-a vozaƒça: $e');
      return null;
    }
  }

  /// üìß VALIDIRAJ FORMAT EMAIL-A
  static bool isValidEmailFormat(String email) {
    final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
    return emailRegex.hasMatch(email);
  }

  // PRIVATNE HELPER METODE

  static Future<void> _updateSMSConfirmationStatus(
      String phoneNumber, bool confirmed) async {
    try {
      final prefs = await SharedPreferences.getInstance();

      // Pronaƒëi vozaƒça po broju telefona
      String? driverName;
      for (final entry in _driverPhones.entries) {
        if (entry.value == phoneNumber) {
          driverName = entry.key;
          break;
        }
      }

      if (driverName != null) {
        await prefs.setBool('phone_confirmed_$driverName', confirmed);
        dlog('‚úÖ A≈æuriran status SMS potvrde za vozaƒça: $driverName');
      }
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri a≈æuriranju statusa SMS potvrde: $e');
    }
  }

  static Future<void> _saveCurrentSession(
      String driverName, String phoneNumber) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('current_session_driver', driverName);
      await prefs.setString('current_session_phone', phoneNumber);
      dlog('‚úÖ Saƒçuvana trenutna sesija za vozaƒça: $driverName');
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri ƒçuvanju trenutne sesije: $e');
    }
  }

  static Future<void> _clearCurrentSession() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('current_session_driver');
      await prefs.remove('current_session_phone');
      dlog('‚úÖ Obrisana trenutna sesija');
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri brisanju trenutne sesije: $e');
    }
  }

  // EMAIL AUTH HELPER METODE

  static Future<void> _saveDriverEmailData(
      String driverName, String email) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('driver_email_$driverName', email);
      await prefs.setBool('email_confirmed_$driverName', false);
      dlog('‚úÖ Saƒçuvani podaci o email-u za vozaƒça: $driverName');
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri ƒçuvanju podataka o email-u: $e');
    }
  }

  static Future<void> _updateEmailConfirmationStatus(
      String email, bool confirmed) async {
    try {
      final prefs = await SharedPreferences.getInstance();

      // Pronaƒëi vozaƒça po email-u
      String? driverName;
      for (final entry in _driverPhones.entries) {
        final driverEmail = prefs.getString('driver_email_${entry.key}');
        if (driverEmail == email) {
          driverName = entry.key;
          break;
        }
      }

      if (driverName != null) {
        await prefs.setBool('email_confirmed_$driverName', confirmed);
        dlog('‚úÖ A≈æuriran status email potvrde za vozaƒça: $driverName');
      }
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri a≈æuriranju statusa email potvrde: $e');
    }
  }

  static Future<void> _saveCurrentEmailSession(
      String driverName, String email) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('current_session_driver', driverName);
      await prefs.setString('current_session_email', email);
      dlog('‚úÖ Saƒçuvana trenutna email sesija za vozaƒça: $driverName');
    } catch (e) {
      dlog('‚ùå Gre≈°ka pri ƒçuvanju trenutne email sesije: $e');
    }
  }
}

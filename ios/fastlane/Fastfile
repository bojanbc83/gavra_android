default_platform(:ios)

platform :ios do
  desc "Build iOS app for cloud CI/CD with manual code signing"
  lane :build_cloud do
    puts "🔍 Environment Variables Check:"
    puts "IOS_CERTIFICATE_BASE64 present: #{!ENV['IOS_CERTIFICATE_BASE64'].nil?}"
    puts "IOS_CERTIFICATE_PASSWORD present: #{!ENV['IOS_CERTIFICATE_PASSWORD'].nil?}"
    puts "IOS_PROVISIONING_PROFILE_BASE64 present: #{!ENV['IOS_PROVISIONING_PROFILE_BASE64'].nil?}"
    
    # Detect and set available Xcode version
    puts "🔍 Detecting Xcode installations..."
    xcode_paths = [
      "/Applications/Xcode_15.4.app",
      "/Applications/Xcode_15.3.app", 
      "/Applications/Xcode_15.2.app",
      "/Applications/Xcode_15.1.app",
      "/Applications/Xcode_15.0.app",
      "/Applications/Xcode.app"
    ]
    
    selected_xcode = nil
    xcode_paths.each do |path|
      if File.exist?("#{path}/Contents/Developer")
        selected_xcode = path
        puts "✅ Found Xcode at: #{path}"
        break
      else
        puts "❌ No Xcode at: #{path}"
      end
    end
    
    if selected_xcode.nil?
      raise "❌ No valid Xcode installation found!"
    end
    
    # Set Xcode path
    xcode_select(selected_xcode)
    puts "🔨 Using Xcode: #{selected_xcode}"
    
    # Create keychain for code signing
    create_keychain(
      name: "ios-build.keychain",
      password: "",
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )
    
    # Check for manual signing secrets
    if ENV["IOS_CERTIFICATE_BASE64"] && ENV["IOS_PROVISIONING_PROFILE_BASE64"]
      puts "🔐 Setting up manual certificate and provisioning profile for CI/CD"
      
      # Import certificate to keychain
      certificate_path = File.expand_path("./ios_certificate.p12")
      puts "📄 Writing certificate to: #{certificate_path}"
      File.write(certificate_path, Base64.decode64(ENV["IOS_CERTIFICATE_BASE64"]))
      puts "✅ Certificate file created, size: #{File.size(certificate_path)} bytes"
      
      begin
        # First validate certificate with openssl before importing
        puts "🔍 Validating certificate with openssl..."
        openssl_result = sh("openssl pkcs12 -in #{certificate_path} -nokeys -noout -passin pass:'#{ENV["IOS_CERTIFICATE_PASSWORD"]}' 2>&1", error_callback: ->(result) { result })
        puts "OpenSSL validation: #{openssl_result}"
        
        if openssl_result.include?("MAC verification failed") || openssl_result.include?("invalid")
          raise "Certificate validation failed - wrong password or corrupted certificate"
        end
        
        import_certificate(
          certificate_path: certificate_path,
          certificate_password: ENV["IOS_CERTIFICATE_PASSWORD"],
          keychain_name: "ios-build"
        )
        puts "✅ Certificate successfully imported to keychain"
      rescue => e
        puts "❌ Certificate import failed: #{e.message}"
        
        # Try to get more certificate info
        puts "🔍 Checking certificate details with different approaches..."
        
        # Try without password
        result1 = sh("openssl pkcs12 -in #{certificate_path} -nokeys -noout 2>&1 || echo 'No-password check failed'")
        puts "No-password check: #{result1}"
        
        # Try with empty password
        result2 = sh("openssl pkcs12 -in #{certificate_path} -nokeys -noout -passin pass: 2>&1 || echo 'Empty-password check failed'")
        puts "Empty-password check: #{result2}"
        
        raise "Certificate import failed - check password and certificate format"
      end
      
      # Import provisioning profile  
      profile_path = File.expand_path("./profile.mobileprovision")
      puts "📄 Writing provisioning profile to: #{profile_path}"
      File.write(profile_path, Base64.decode64(ENV["IOS_PROVISIONING_PROFILE_BASE64"]))
      puts "✅ Profile file created, size: #{File.size(profile_path)} bytes"
      
      install_provisioning_profile(path: profile_path)
      
      # Verify certificate was imported
      puts "🔍 Checking imported certificates in keychain..."
      sh("security find-identity -v -p codesigning ios-build.keychain || true")
      
      # Clean up
      File.delete(certificate_path) if File.exist?(certificate_path)
      File.delete(profile_path) if File.exist?(profile_path)
      
      puts "✅ Manual certificate and profile setup completed"
    else
      puts "⚠️ Manual signing secrets not found - using automatic signing (local development)"
    end

    # Build the app
    puts "🔨 Starting iOS build process..."
    workspace_path = File.expand_path("../Runner.xcworkspace")
    puts "Workspace path: #{workspace_path}"
    puts "Workspace exists: #{File.exist?(workspace_path)}"

    begin
      build_app(
        workspace: workspace_path,
        scheme: "Runner",
        configuration: "Release",
        export_method: "app-store",
        destination: "generic/platform=iOS",
        sdk: "iphoneos",
        skip_package_dependencies_resolution: true,
        xcargs: "DEVELOPMENT_TEAM=6CY9Q44KMQ CODE_SIGN_STYLE=Manual IPHONEOS_DEPLOYMENT_TARGET=14.0",
        export_options: {
          method: "app-store",
          teamID: "6CY9Q44KMQ",
          signingStyle: "manual",
          provisioningProfiles: {
            "com.gavra013.gavraAndroid" => "Gavra 013 App Store Profile"
          }
        }
      )
      puts "✅ Build completed successfully!"
      
      # Check what files were created
      puts "📁 Checking build output files..."
      Dir.glob("**/*.ipa").each do |ipa_file|
        puts "Found IPA: #{ipa_file} (#{File.size(ipa_file)} bytes)"
      end
      
      # Try to find the IPA file
      ipa_path = Actions.lane_context[SharedValues::IPA_OUTPUT_PATH]
      if ipa_path && File.exist?(ipa_path)
        puts "✅ Found IPA at lane context path: #{ipa_path}"
      else
        puts "⚠️  IPA not found at lane context path: #{ipa_path}"
        # Look for IPA files in common locations
        possible_ipa_paths = [
          "./Runner.ipa",
          "./build/ios/iphoneos/Runner.ipa",
          "../build/ios/ipa/Runner.ipa"
        ]
        
        possible_ipa_paths.each do |path|
          if File.exist?(path)
            puts "✅ Found IPA at: #{path}"
            ipa_path = path
            break
          end
        end
      end
      
      if ipa_path && File.exist?(ipa_path)
        puts "📱 Final IPA path: #{ipa_path}"
        puts "📏 IPA size: #{File.size(ipa_path)} bytes"
      else
        puts "❌ No IPA file found!"
      end
      
    rescue => e
      puts "❌ Build failed: #{e.message}"
      raise e
    end
  end

  desc "Upload to TestFlight using App Store Connect API"
  lane :upload_testflight do
    puts "🚀 Uploading to TestFlight..."
    
    # Find the IPA file
    ipa_path = Actions.lane_context[SharedValues::IPA_OUTPUT_PATH] || 
               Dir.glob("**/*.ipa").first
    
    if ipa_path.nil? || !File.exist?(ipa_path)
      raise "❌ No IPA file found for upload"
    end
    
    puts "📱 Uploading IPA: #{ipa_path}"
    
    begin
      upload_to_testflight(
        api_key_path: "../AuthKey_F4P3BUR78G.p8",
        api_key: {
          key_id: "F4P3BUR78G",
          issuer_id: "d8b50e72-6330-401d-9aef-4ead356405ca",
          key_filepath: "../AuthKey_F4P3BUR78G.p8"
        },
        skip_waiting_for_build_processing: true,
        skip_submission: true,
        ipa: ipa_path
      )
      puts "✅ Successfully uploaded to TestFlight!"
    rescue => e
      puts "❌ TestFlight upload failed: #{e.message}"
      raise e
    end
  end

  desc "Complete build and upload process"
  lane :build_and_upload do
    build_cloud
    upload_testflight
  end
end